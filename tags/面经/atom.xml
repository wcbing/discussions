<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>炳的自留地 – 面经</title>
    <link>/tags/%E9%9D%A2%E7%BB%8F/</link>
    <description>Recent content in 面经 on 炳的自留地</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 04 Apr 2023 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="/tags/%E9%9D%A2%E7%BB%8F/atom.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>计网应用层笔记</title>
      <link>/network/layer-application/</link>
      <pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>/network/layer-application/</guid>
      <description>
        
        
        &lt;p&gt;最近在看计网自顶向下，那就找点计网的面试题/总结看看。
先来应用层的，应用层重点就是HTTP了吧，还有就是SSL/TLS相关的公钥加密（非对称加密）以及DNS。&lt;/p&gt;
&lt;h2&gt;DNS&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;dns&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#dns&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;DNS - Domain Name System，域名系统&lt;/p&gt;
&lt;p&gt;域名，其实说白了就是给&lt;code&gt;IP地址&lt;/code&gt;起得（便于人类记忆的）别名，域名系统就是负责这个转换过程的。而一般一个 IP 对应一台主机，所以域名也算是一种&lt;code&gt;主机名&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;hosts&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;hosts&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#hosts&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;说到这里不得不提一下 &lt;code&gt;hosts&lt;/code&gt; 文件了。不管你是Windows、Linux还是Android、iOS,你的系统里都有一个 &lt;code&gt;hosts&lt;/code&gt; 文件，这个文件里是一系列形如 &lt;code&gt;IP 主机名&lt;/code&gt; 的对应列表（最有名的的应该就是&lt;code&gt;localhost&lt;/code&gt;了）。当你访问&lt;code&gt;主机名&lt;/code&gt;时，可以自动将其转换为 IP 地址，如果hosts中没有，再去DNS中查询。
所以呢，这个 DNS 就可以看作是大型的、分布式、特殊规范化的 &lt;code&gt;hosts&lt;/code&gt; “文件”。（我自己说的，方便理解）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为通过 hosts 能绕过 DNS 服务器的解析，所以前几年（大概我小学、初中时）这是访问 Google 等网站一个常用的绕过 “DNS 污染” 的方法。可惜现在技术早就升级了😁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;域名解析&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;域名解析&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%9f%9f%e5%90%8d%e8%a7%a3%e6%9e%90&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;DNS查询有两种方式：递归和迭代。
DNS客户端设置使用的DNS服务器一般都是递归服务器，它负责全权处理客户端的DNS查询请求，直到返回最终结果。而DNS服务器之间一般采用迭代查询方式。&lt;/p&gt;
&lt;h3&gt;域名层次空间&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;域名层次空间&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%9f%9f%e5%90%8d%e5%b1%82%e6%ac%a1%e7%a9%ba%e9%97%b4&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;域名系统中的任何名称都是域名。在域名系统的层次结构中，各种域名都隶属于域名系统根域的下级。
域名的第一级是顶级域，它包括通用顶级域，例如.com、.net和.org；以及国家和地区顶级域，例如.us、.cn和.tk等。顶级域名下一层是二级域名，一级一级地往下。&lt;/p&gt;
&lt;h3&gt;顶级域（TLD）&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;顶级域tld&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%a1%b6%e7%ba%a7%e5%9f%9ftld&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;单独列一下顶级域。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础结构域
只有一个&lt;code&gt;arpa&lt;/code&gt;，用于反向域名解析。有时被认为是通用顶级域&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E9%A0%82%E7%B4%9A%E5%9F%9F&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;通用顶级域（gTLD）&lt;/a&gt;（共二十多个）
&lt;ul&gt;
&lt;li&gt;1985创立，共六个
&lt;code&gt;.com&lt;/code&gt;、&lt;code&gt;.edu&lt;/code&gt;、&lt;code&gt;.gov&lt;/code&gt;、&lt;code&gt;.mil&lt;/code&gt;、&lt;code&gt;.net&lt;/code&gt;、&lt;code&gt;.org&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2000年，新增
&lt;code&gt;.aero&lt;/code&gt;、&lt;code&gt;.biz&lt;/code&gt;、&lt;code&gt;.coop&lt;/code&gt;、&lt;code&gt;.info&lt;/code&gt;、&lt;code&gt;.museum&lt;/code&gt;、&lt;code&gt;.name&lt;/code&gt;、&lt;code&gt;.pro&lt;/code&gt;（所以 &lt;code&gt;.name&lt;/code&gt; 和 &lt;code&gt;.pro&lt;/code&gt; 也算是老牌域名了）&lt;/li&gt;
&lt;li&gt;2005年，又公布一批
(包括&lt;code&gt;.xxx&lt;/code&gt;，但当时未启用)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;国家顶级域（ccTLD）
可看&lt;a href=&#34;/blog/region_lang_code/&#34; &gt;国家地区代码&lt;/a&gt;，基本遵守 &lt;code&gt;ISO 3166-1&lt;/code&gt; 两字母代码&lt;/li&gt;
&lt;li&gt;新通用顶级域名（New gTLD）
2011 年 ICANN 理事会正式批准新通用顶级域名申请计划。
&lt;ul&gt;
&lt;li&gt;国际化域名（IDN）
使用特殊的文字或非拉丁字母组成，如&lt;code&gt;.中国&lt;/code&gt;。国际化域名使用Punycode转写储存，都以 &lt;code&gt;.xn--&lt;/code&gt; 开头。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各顶级域域名数据数量统计：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://domainnamestat.com/statistics/overview/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Domain Name Stat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://domainsproject.org/STATS.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Domains Project（非即时）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;WHOIS（域名数据库查询）&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;whois域名数据库查询&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#whois%e5%9f%9f%e5%90%8d%e6%95%b0%e6%8d%ae%e5%ba%93%e6%9f%a5%e8%af%a2&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;查询域名所有者。
可看 &lt;a href=&#34;/network/tools&#34; &gt;网络相关常用工具&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;HTTP - 超文本传输协议&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http---超文本传输协议&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http---%e8%b6%85%e6%96%87%e6%9c%ac%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;无连接与无状态&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;无连接与无状态&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%97%a0%e8%bf%9e%e6%8e%a5%e4%b8%8e%e6%97%a0%e7%8a%b6%e6%80%81&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;使用 TCP 作为传输层协议，但是HTTP本身是&lt;strong&gt;无连接&lt;/strong&gt;的，即交换HTTP报文前不用建立 HTTP 连接。&lt;/p&gt;
&lt;p&gt;HTTP是&lt;strong&gt;无状态&lt;/strong&gt;的，多次访问的响应应该相同。&lt;/p&gt;
&lt;h3&gt;HTTP 常用状态码&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http-常用状态码&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http-%e5%b8%b8%e7%94%a8%e7%8a%b6%e6%80%81%e7%a0%81&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;先来点有趣的。这里当然先是查一查我们亲爱的 MDN 啦：&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP 响应状态码 - HTTP|MDN&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;状态码分类&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;状态码分类&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e7%8a%b6%e6%80%81%e7%a0%81%e5%88%86%e7%b1%bb&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;(100–199) 信息响应，表示目前是协议的中间状态，还需要后续请求&lt;/li&gt;
&lt;li&gt;(200–299) 成功响应&lt;/li&gt;
&lt;li&gt;(300–399) 重定向消息&lt;/li&gt;
&lt;li&gt;(400–499) 客户端错误响应&lt;/li&gt;
&lt;li&gt;(500–599) 服务端错误响应&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;常用状态码&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;常用状态码&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%b8%b8%e7%94%a8%e7%8a%b6%e6%80%81%e7%a0%81&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;101 切换请求协议，从 HTTP 切换到 WebSocket&lt;/li&gt;
&lt;li&gt;200 请求成功，有响应体&lt;/li&gt;
&lt;li&gt;301 永久重定向：会缓存，类似的还有 308&lt;/li&gt;
&lt;li&gt;302 临时重定向：不会缓存，类似的还有 303、307&lt;/li&gt;
&lt;li&gt;304 协商缓存命中&lt;/li&gt;
&lt;li&gt;400 请求错误&lt;/li&gt;
&lt;li&gt;403 服务器禁止访问&lt;/li&gt;
&lt;li&gt;404 资源未找到&lt;/li&gt;
&lt;li&gt;500 服务器端错误&lt;/li&gt;
&lt;li&gt;503 服务器繁忙&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前几个月看到的梗图:
&lt;img src=&#34;http-status-wumen.jpg&#34; alt=&#34;image&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;更多（梗图）：&lt;a href=&#34;https://www.zhihu.com/answer/1819211527&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;有哪些是程序员才懂的梗？然然然：HTTP状态码&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;连接管理&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;连接管理&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e8%bf%9e%e6%8e%a5%e7%ae%a1%e7%90%86&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;长连接与短连接（持久连接与非持久连接）&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;长连接与短连接持久连接与非持久连接&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%95%bf%e8%bf%9e%e6%8e%a5%e4%b8%8e%e7%9f%ad%e8%bf%9e%e6%8e%a5%e6%8c%81%e4%b9%85%e8%bf%9e%e6%8e%a5%e4%b8%8e%e9%9d%9e%e6%8c%81%e4%b9%85%e8%bf%9e%e6%8e%a5&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求其他网页元素对象（如图片资源）。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。&lt;/p&gt;
&lt;p&gt;长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；
在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;流水线与非流水线&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;流水线与非流水线&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%b5%81%e6%b0%b4%e7%ba%bf%e4%b8%8e%e9%9d%9e%e6%b5%81%e6%b0%b4%e7%ba%bf&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;持久连接又分为非流水线和流水线两种方式。&lt;/p&gt;
&lt;p&gt;对于非流水线方式，客户在收到前一个响应后才能发出下一个请求，服务器发送完-一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。
而流水线方式下客户每遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对各个引用对象的请求。这种方式减少了TCP连接中的空闲时间，提高了效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP/1.1 的默认方式是使用流水线的持久连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;HTTP1.0，1.1，2.0 的版本区别&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http101120-的版本区别&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http101120-%e7%9a%84%e7%89%88%e6%9c%ac%e5%8c%ba%e5%88%ab&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;HTTP/1.0&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http10&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http10&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;1996年5月，HTTP/1.0 版本发布，为了提高系统的效率，HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。&lt;/p&gt;
&lt;p&gt;HTTP/1.0中浏览器与服务器只保持短暂的连接，&lt;strong&gt;连接无法复用&lt;/strong&gt;。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。&lt;/p&gt;
&lt;p&gt;TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP/1.0版本的性能比较差。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP1.0 其实也可以强制开启长链接，例如接受Connection: keep-alive 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;HTTP/1.1&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http11&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http11&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;为了解决HTTP/1.0存在的缺陷，HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了&lt;strong&gt;持久连接&lt;/strong&gt;。所谓的持久连接即&lt;strong&gt;TCP连接默认不关闭&lt;/strong&gt;，可以被多个请求复用。&lt;/p&gt;
&lt;p&gt;客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。&lt;/p&gt;
&lt;p&gt;HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。&lt;/p&gt;
&lt;p&gt;有了持久连接和管道，大大的提升了HTTP的效率。但是服务端还是顺序执行的，效率还有提升的空间。&lt;/p&gt;
&lt;h3&gt;HTTP/2&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http2&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http2&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;HTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议。&lt;/p&gt;
&lt;p&gt;HTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了&lt;strong&gt;多路复用&lt;/strong&gt;。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了&lt;strong&gt;二进制分帧&lt;/strong&gt;，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。&lt;/p&gt;
&lt;p&gt;除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Header压缩就是压缩对话。&lt;/li&gt;
&lt;li&gt;服务端推送就是还没有收到浏览器的请求，服务器就把各种资源推送给浏览器（缓存）上。这样需要的时候就可以直接读取缓存了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;呃&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;呃&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%91%83&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;目前，主流的HTTP协议是HTTP/2，部分为HTTP/1.1。&lt;/p&gt;
&lt;p&gt;这让我想起来之前知乎看到的一个回答 &lt;a href=&#34;https://www.zhihu.com/question/554796551/answer/2688086521&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;浏览器开两个窗口分别访问百度，各自窗口会单独创建tcp连接吗，还是复用之前的tcp？ - 紫云飞&lt;/a&gt; ，里面提到百度的主站是现在为数不多的HTTP/1.1了，看了看，确实。&lt;/p&gt;
&lt;h2&gt;HTTP 方法&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http-方法&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http-%e6%96%b9%e6%b3%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;HTTP 方法有哪些？&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;http-方法有哪些&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#http-%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;HTTP 定义了一组请求方法，以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每一个请求方法都实现了不同的语义，但一些共同的特征由一组共享：例如一个请求方法可以是&lt;strong&gt;安全的、幂等的或可缓存的&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;GET 方法
请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据。(但当前网络中绝大部分使用的都是 GET)&lt;/li&gt;
&lt;li&gt;HEAD 方法
请求一个与 GET 请求的响应相同的响应，但没有响应体。&lt;/li&gt;
&lt;li&gt;POST 方法
用于&lt;strong&gt;将实体提交&lt;/strong&gt;到指定的资源，通常导致在服务器上的状态变化或副作用。&lt;/li&gt;
&lt;li&gt;PUT 方法
用有效载荷请求&lt;strong&gt;替换目标资源&lt;/strong&gt;的所有当前表示。(由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。)&lt;/li&gt;
&lt;li&gt;DELETE 方法
&lt;strong&gt;删除&lt;/strong&gt;指定的资源。（与 PUT 功能相反，并且同样不带验证机制）&lt;/li&gt;
&lt;li&gt;CONNECT 方法
建立一个到由目标资源标识的服务器的隧道。随后使用 SSL 和 TLS 协议把通信内容加密后经网络隧道传输。&lt;/li&gt;
&lt;li&gt;OPTIONS 方法
用于描述目标资源的通信选项。（支持的方法）&lt;/li&gt;
&lt;li&gt;TRACE 方法
沿着到目标资源的路径执行一个消息环回测试。（追踪路径。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。）&lt;/li&gt;
&lt;li&gt;PATCH 方法
用于对资源应用&lt;strong&gt;部分修改&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP 请求方法 - HTTP|MDN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;POST和GET有哪些区别？各自应用场景？&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;post和get有哪些区别各自应用场景&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#post%e5%92%8cget%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8c%ba%e5%88%ab%e5%90%84%e8%87%aa%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4&gt;使用场景&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;使用场景&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;GET 用于获取资源，而 POST 用于传输实体主体。&lt;/p&gt;
&lt;h4&gt;参数&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;参数&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%8f%82%e6%95%b0&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;pre&gt;&lt;code&gt;GET /test?name1=value1&amp;amp;name2=value2 HTTP/1.1&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;pre&gt;&lt;code&gt;POST /test HTTP/1.1
Host: example.com
name1=value1&amp;amp;name2=value2&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行 URL 编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。&lt;/p&gt;
&lt;h4&gt;安全性&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;安全性&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%ae%89%e5%85%a8%e6%80%a7&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。&lt;/p&gt;
&lt;p&gt;GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。&lt;/p&gt;
&lt;p&gt;安全的方法除了 GET 之外还有：HEAD、OPTIONS。&lt;/p&gt;
&lt;p&gt;不安全的方法除了 POST 之外还有 PUT、DELETE。&lt;/p&gt;
&lt;h4&gt;幂等性&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;幂等性&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%b9%82%e7%ad%89%e6%80%a7&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。&lt;/p&gt;
&lt;p&gt;所有的安全方法也都是幂等的。&lt;/p&gt;
&lt;p&gt;在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。&lt;/p&gt;
&lt;p&gt;GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;pre&gt;&lt;code&gt;GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1
GET /pageX HTTP/1.1&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;pre&gt;&lt;code&gt;POST /add_row HTTP/1.1   -&amp;gt; Adds a 1nd row
POST /add_row HTTP/1.1   -&amp;gt; Adds a 2nd row
POST /add_row HTTP/1.1   -&amp;gt; Adds a 3rd row&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;pre&gt;&lt;code&gt;DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 200 if idX exists
DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 404 as it just got deleted
DELETE /idX/delete HTTP/1.1   -&amp;gt; Returns 404&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;h4&gt;可缓存&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;可缓存&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e5%8f%af%e7%bc%93%e5%ad%98&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;如果要对响应进行缓存，需要满足以下条件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
响应报文的 Cache-Control 首部字段没有指定不进行缓存。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;XMLHttpRequest&lt;/p&gt;
&lt;p&gt;为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 

在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
而 GET 方法 Header 和 Data 会一起发送。
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.iamshuaidi.com/683.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;POST和GET有哪些区别？各自应用场景？ - 帅地玩编程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;不想写了&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;不想写了&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e4%b8%8d%e6%83%b3%e5%86%99%e4%ba%86&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.iamshuaidi.com/673.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;计算机网络面试真题 - 帅地玩编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bgww.apachecn.org/HTTP-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88Cyc2018%EF%BC%89/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP 学习笔记（Cyc2018） - 【布客】八股文知识库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;收藏夹翻出来的，计网面试题都总结好了，怎么办，不想写了😭。&lt;/p&gt;
      </description>
    </item>
    
  </channel>
</rss>
